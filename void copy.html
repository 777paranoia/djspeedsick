<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Void City</title>
<style>
  html,body{margin:0;padding:0;overflow:hidden;background:#000}
  canvas#c{position:fixed;inset:0;display:block;width:100vw;height:100vh;}

  #splash-screen{
    position: fixed;
    inset: 0;
    z-index: 9999;
    background: #000;
  }

  #background-overlay{
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    object-fit: cover;
  }

  #enter-button{
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    cursor: pointer;
    z-index: 2;
  }
</style>
</head>
<body>

<div id="splash-screen">
  <img id="background-overlay" src="files/img/aerial.png">
  <img id="enter-button"
       src="files/img/enter-transparency2.png"
       onclick="enterSite()">
</div>
<canvas id="c"></canvas>

<script>
function enterSite(){
  const splash = document.getElementById("splash-screen");
  const audio = document.getElementById("audioPlayer");
  if (audio) audio.play().catch(()=>{});
  splash.style.display = "none";
}
</script>

<script id="simFrag" type="x-shader/x-fragment">
precision highp float;
uniform sampler2D u_prev;
uniform sampler2D u_window;
uniform vec2  u_resolution;
uniform float u_time;
uniform float u_dt;

float hash(vec2 p){ return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453); }
float hash1(float x){ return fract(sin(x*127.1)*43758.5); }

void main(){
  vec2 uv = gl_FragCoord.xy / u_resolution;
  vec4 win = texture2D(u_window, uv);
  float isGlass = 1.0 - clamp(win.a, 0.0, 1.0);
  if(isGlass < 0.1){ gl_FragColor = vec4(0.0); return; }

  vec2 texel = 1.0 / u_resolution;
  vec4 prev = texture2D(u_prev, uv);

  float h    = prev.r;

  float band     = floor(uv.x * 12.0);
  float depthRd  = hash1(band * 9.17);
  float speedMul = mix(0.55, 1.55, depthRd);
  float thickMul = mix(0.65, 1.85, depthRd);

  float cols   = 36.0 + depthRd * 56.0;
  float colId  = floor(uv.x * cols);
  float colRnd = hash1(colId * 3.7 + 1.3);
  float colRnd2= hash1(colId * 7.1 + 5.9);

  float spawnT1  = step(0.935, fract(u_time * (0.12 + colRnd  * 0.16) * speedMul + colRnd2 * 13.7));
  float spawnT2  = step(0.965, fract(u_time * (0.08 + colRnd2 * 0.11) * speedMul + colRnd  * 7.3));
  float spawnRnd = hash(uv * vec2(1.0, 2.2) + vec2(floor(u_time * (1.7 + colRnd * 1.9)), band * 11.0));

  float spawnCol = (spawnT1 + spawnT2) * step(0.62, spawnRnd) * step(0.5, isGlass);
  float newDrop  = spawnCol * (0.85 + 1.35 * depthRd);

  vec4 above = texture2D(u_prev, uv - vec2(0.0, texel.y * (2.0 + depthRd * 2.0)));
  float flowIn = above.r * (0.22 + 0.38 * depthRd);

  float breakup  = mix(0.985, 0.965, hash(vec2(colId, floor(u_time*1.2 + depthRd*9.0))));
  float dryPulse = mix(0.00, 0.08, step(0.985, hash(vec2(colId*2.3, floor(u_time*0.8)))));

  h = h * (0.92 * breakup) + flowIn + newDrop * (0.045 * thickMul);
  h = clamp(h, 0.0, 1.0);

  h *= (0.989 - dryPulse*0.25);
  float flowOut = smoothstep(0.18, 0.88, h) * (0.20 + 0.22 * depthRd);
  h = clamp(h - flowOut, 0.0, 1.0);

  h *= isGlass;

  gl_FragColor = vec4(h, 0.0, depthRd, 1.0);
}
</script>

<script id="frag" type="x-shader/x-fragment">
precision highp float;

uniform vec2  u_resolution;
uniform float u_time;
uniform vec2  u_mouse;
uniform float u_blink;
uniform int   u_mode;
uniform float u_flash;
uniform float u_shake;

uniform sampler2D u_texB1,u_texB2,u_texB3,u_texB4,u_texB5,u_texB6;
uniform sampler2D u_texSkyline,u_texWindow;
uniform sampler2D u_texBH;
uniform sampler2D u_water;
uniform sampler2D u_texMirror;

#define PI 3.14159265359

float hash2(vec2 p){ return fract(sin(dot(p,vec2(12.9898,78.233)))*43758.5453); }
float hash1(float x){ return fract(sin(x*127.1)*43758.5); }
mat2 rot(float a){ float s=sin(a),c=cos(a); return mat2(c,-s,s,c); }

float sdBox(vec3 p,vec3 b){
  vec3 q=abs(p)-b;
  return length(max(q,0.0))+min(max(q.x,max(q.y,q.z)),0.0);
}

/* --- Fractal (modes 1/2) --- */
float sdFractal(vec3 p) {
  p.xz *= rot(u_time * 0.5);
  p.yz *= rot(u_time * 0.3);
  float s = 1.0;
  for(int i=0; i<4; i++) {
    p = abs(p) - 0.6;
    p.xy *= rot(0.5);
    p.xz *= rot(0.1);
    p *= 1.5; s *= 1.5;
  }
  return sdBox(p, vec3(0.5)) / s;
}

vec3 neonPalette(float t) {
  vec3 a = vec3(0.5, 0.5, 0.5);
  vec3 b = vec3(0.5, 0.5, 0.5);
  vec3 c = vec3(1.0, 1.0, 1.0);
  vec3 d = vec3(0.00, 0.33, 0.67);
  return a + b * cos(6.28318 * (c * t + d));
}

vec3 fractalAnchor(float id){
  float x = mix(-6.0,  6.0, hash1(id*3.1));
  float y = mix(-1.0,  3.0, hash1(id*7.3));
  float z = mix( 7.0, 18.0, hash1(id*11.7));
  return vec3(x, y, z);
}

float snow(vec2 uv,float size,float speed,float opacity){
  vec2 grid=uv*size;
  vec2 id=floor(grid);
  vec2 f=fract(grid)-0.5;
  f.y+=fract(u_time*speed+hash2(id)*15.0)-0.5;
  f.x+=sin(u_time*0.5+hash2(id)*6.2831)*0.2;
  return smoothstep(.05,0.0,length(f))*hash2(id)*opacity;
}

/* --- WORLD RAIN (outside, depth layered) --- */
float worldRainLayer(vec2 uv, float t, float scale, float speed, float thickness, float density, float slant){
  vec2 u = uv;
  u.x *= u_resolution.x / u_resolution.y;
  u *= scale;
  u += vec2(slant, 1.0) * t * speed;

  vec2 id = floor(u);
  vec2 f  = fract(u);

  float n = hash2(id);
  float on = step(1.0 - density, n);

  float x = f.x - (0.5 + (n - 0.5) * 0.18);
  float streak = smoothstep(thickness, 0.0, abs(x));

  float seg = hash2(id + 19.17);
  float gate = smoothstep(0.15, 0.95, fract(f.y + seg));

  return on * streak * gate;
}

float worldRain(vec2 uv, float t){
  float r = 0.0;
  r += worldRainLayer(uv, t, 18.0, 1.8, 0.020, 0.10, 0.06);
  r += worldRainLayer(uv, t, 28.0, 2.4, 0.016, 0.13, 0.08);
  r += worldRainLayer(uv, t, 44.0, 3.2, 0.012, 0.16, 0.10);
  return clamp(r, 0.0, 1.0);
}

/* --- Scene --- */
vec2 mapScene(vec3 p){
  vec2 res=vec2(1000.0,-1.0);
  float d1=sdBox(p-vec3(-3.0,0.0,2.0), vec3(1.2,12.0,1.5)); if(d1<res.x) res=vec2(d1,1.0);
  float d2=sdBox(p-vec3(-4.2,0.0,7.0), vec3(1.2,12.0,1.5)); if(d2<res.x) res=vec2(d2,2.0);
  float d3=sdBox(p-vec3(-5.4,0.0,12.0),vec3(1.2,12.0,1.5)); if(d3<res.x) res=vec2(d3,3.0);
  float d4=sdBox(p-vec3( 3.0,0.0,2.5), vec3(1.2,12.0,1.5)); if(d4<res.x) res=vec2(d4,4.0);
  float d5=sdBox(p-vec3( 4.2,0.0,7.5), vec3(1.2,12.0,1.5)); if(d5<res.x) res=vec2(d5,5.0);
  float d6=sdBox(p-vec3( 5.4,0.0,12.5),vec3(1.2,12.0,1.5)); if(d6<res.x) res=vec2(d6,6.0);

  if(u_mode == 1 || u_mode == 2){
    float id = floor(u_time * 0.2);
    vec3 anchor = fractalAnchor(id);
    vec3 fp = p - anchor;

    float guardDist = length(fp) - 2.5;
    float dFract = max(guardDist, sdFractal(fp));

    if(dFract < res.x) res = vec2(dFract, 10.0);
  }

  return res;
}

vec3 sampleBuilding(float id,vec2 texUV){
  if(id > 9.0) return vec3(1.0);
  vec2 uv=abs(fract(texUV*0.25)*2.0-1.0);
  if(id<1.5) return texture2D(u_texB1,uv).rgb;
  if(id<2.5) return texture2D(u_texB2,uv).rgb;
  if(id<3.5) return texture2D(u_texB3,uv).rgb;
  if(id<4.5) return texture2D(u_texB4,uv).rgb;
  if(id<5.5) return texture2D(u_texB5,uv).rgb;
  return texture2D(u_texB6,uv).rgb;
}

/* --- Water normal from sim height --- */
vec2 waterNormal(vec2 uv){
  vec2 texel = 1.0 / u_resolution;
  float hL = texture2D(u_water, uv - vec2(texel.x, 0.0)).r;
  float hR = texture2D(u_water, uv + vec2(texel.x, 0.0)).r;
  float hD = texture2D(u_water, uv - vec2(0.0, texel.y)).r;
  float hU = texture2D(u_water, uv + vec2(0.0, texel.y)).r;
  return vec2(hL - hR, hD - hU) * 7.0;
}

void main(){
  vec2 uv=(gl_FragCoord.xy-0.5*u_resolution.xy)/u_resolution.y;
  vec2 screenUV=gl_FragCoord.xy/u_resolution.xy;
  vec2 m=u_mouse*0.35;

  vec3 ro=vec3(0.0,0.0,-4.5);
  vec3 rd=normalize(vec3(uv,1.4));
  rd.yz*=rot(-m.y*0.5);
  rd.xz*=rot(-m.x*0.6);

  if(u_mode==3){
    float sx=(hash2(vec2(floor(u_time*40.0),1.7))-0.5)*0.020*u_shake;
    float sy=(hash2(vec2(floor(u_time*40.0),8.3))-0.5)*0.016*u_shake;
    rd.xz*=rot(sx); rd.yz*=rot(sy);
  }

  float t=0.0; vec2 hit=vec2(0.0);
  for(int i=0;i<90;i++){
    hit=mapScene(ro+rd*t);
    if(hit.x<0.001||t>70.0) break;
    t+=hit.x;
  }
  bool isSky=(t>=70.0);

  vec3 colorStorm=vec3(0.008,0.018,0.040);
  vec3 skyTone=(u_mode==3)
    ? mix(colorStorm,vec3(0.015,0.030,0.060),exp(-max(rd.y,0.0)*3.5))
    : mix(vec3(0.01,0.02,0.04),vec3(0.35,0.20,0.08),exp(-max(rd.y,0.0)*4.0));

  vec3 sceneCol=vec3(0.0);

  if(!isSky){
    vec3 p=ro+rd*t;
    vec3 n=normalize(vec3(
      mapScene(p+vec3(0.01,0,0)).x-mapScene(p-vec3(0.01,0,0)).x,
      mapScene(p+vec3(0,0.01,0)).x-mapScene(p-vec3(0,0.01,0)).x,
      mapScene(p+vec3(0,0,0.01)).x-mapScene(p-vec3(0,0,0.01)).x
    ));
    vec2 texUV=(abs(n.x)>abs(n.y))?p.zy:p.xy;

    float fogAmt = (u_mode == 3) ? (1.0-exp(-0.004*t*t)) : (1.0-exp(-0.015*t*t));
    float buildAmt = (u_mode == 3) ? 0.22 : 0.45;
    sceneCol=mix(sampleBuilding(hit.y,texUV)*buildAmt, skyTone, fogAmt);

    if(hit.y > 9.0){
      float id = floor(u_time * 0.2);
      vec3 anchor = fractalAnchor(id);
      vec3 fp2 = p - anchor;
      float b1 = fp2.x * 8.0 + fp2.z * 6.0 + u_time * 0.5;
      float b2 = fp2.y * 9.0 - fp2.x * 5.0 + u_time * 0.37;
      float b3 = length(fp2.xz) * 12.0 + u_time * 0.43;
      float t_pal = fract(b1*0.3 + b2*0.3 + b3*0.4);
      sceneCol = neonPalette(t_pal);
    }

    if(u_mode==3) sceneCol+=vec3(0.55,0.78,1.0)*u_flash*0.35;

  } else {
    if(u_mode==3){
      vec2 bhUV = rd.xy * 0.40 + vec2(0.5, 0.5);
      bhUV = clamp(bhUV, 0.001, 0.999);
      sceneCol=texture2D(u_texBH, bhUV).rgb;
    } else {
      vec2 skyUV=fract(rd.xy*0.5+0.5+vec2(u_time*0.002,0.0));
      sceneCol=texture2D(u_texSkyline,skyUV).rgb*0.3+skyTone*0.5;

      if(u_mode==1 || u_mode==2){
        sceneCol.r += sin(u_time*2.0 + uv.y*10.0)*0.05;
        sceneCol.b += cos(u_time*2.0 + uv.x*10.0)*0.05;
      }

      sceneCol+=snow(vec2(atan(rd.z,rd.x)*2.0,rd.y*2.0),15.0,0.3,0.3);
    }
  }

  // ADD: outside-world rain (only on sky pixels; prevents painting onto buildings)
  if(u_mode==3){
    float wr = worldRain(uv, u_time);
    wr *= isSky ? 1.0 : 0.0;
    sceneCol += vec3(0.62,0.72,0.85) * wr * 0.65;
  }

  // ADD: Mode 4 - display mirror image
  if(u_mode==4){
    vec2 suv = gl_FragCoord.xy / u_resolution.xy;
    sceneCol = texture2D(u_texMirror, vec2(suv.x, 1.0 - suv.y)).rgb;
  }

  // Window overlay (frame + glass effects)
  float dWin=(-1.5-ro.z)/rd.z;
  if(dWin>0.0){
    vec3 pW=ro+rd*dWin;
    if(abs(pW.x)<4.0&&abs(pW.y)<3.0){
      vec2 wuv=vec2(pW.x*0.25+0.5,0.5-pW.y*0.25);
      vec4 txW=texture2D(u_texWindow,wuv);
      float frameA=clamp(txW.a,0.0,1.0);
      float isGlass=1.0-frameA;

      if(isGlass>0.1 && u_mode==3){
        float waterH = texture2D(u_water, wuv).r;
        vec2  wNorm  = waterNormal(wuv);

        float highlight = clamp(dot(normalize(wNorm), normalize(vec2(0.25,0.85))), 0.0, 1.0);
        highlight = pow(highlight, 7.0) * waterH * 1.6;
        float wetness = clamp(waterH * 2.6, 0.0, 0.38);

        float useBH = isSky ? 1.0 : 0.0;

        vec2 bhUV = rd.xy * 0.40 + vec2(0.5, 0.5);
        vec2 refractUV = bhUV + wNorm * 0.020;
        refractUV = clamp(refractUV, 0.001, 0.999);
        vec3 refracted = texture2D(u_texBH, refractUV).rgb;

        float refractAmt = clamp((waterH - 0.12) * 7.0, 0.0, 0.65) * useBH;
        sceneCol = mix(sceneCol, refracted, refractAmt);

        sceneCol += vec3(0.62,0.78,1.0) * highlight;
        sceneCol = mix(sceneCol, sceneCol * 0.72, wetness);

      } else if(isGlass>0.1 && u_mode!=3){
        float frost = hash2(wuv*80.0)*0.04;
        sceneCol = mix(sceneCol, vec3(0.6,0.7,0.8), frost*0.3);
      }

      vec3 frameCol=txW.rgb*0.50;
      if(u_mode==3) frameCol+=vec3(0.55,0.78,1.0)*u_flash*0.55;
      sceneCol=mix(sceneCol,frameCol,frameA);
    }
  }

  gl_FragColor=vec4(sceneCol*(1.0-u_blink),1.0);
}
</script>

<script>
const canvas = document.getElementById("c");
const gl = canvas.getContext("webgl", { antialias:false, alpha:false });
gl.getExtension("OES_texture_float") || gl.getExtension("OES_texture_half_float");

const fit = () => {
  const dpr = Math.min(2, devicePixelRatio||1);
  canvas.width  = Math.floor(innerWidth  * dpr);
  canvas.height = Math.floor(innerHeight * dpr);
  gl.viewport(0,0,canvas.width,canvas.height);
};
addEventListener("resize", () => { fit(); rebuildFBOs(); }); fit();

const compile = (type, src) => {
  const sh = gl.createShader(type);
  gl.shaderSource(sh, src);
  gl.compileShader(sh);
  if(!gl.getShaderParameter(sh, gl.COMPILE_STATUS)) console.error(gl.getShaderInfoLog(sh));
  return sh;
};

const vsrc = `attribute vec2 p; void main(){ gl_Position=vec4(p,0,1); }`;

const simProg = gl.createProgram();
gl.attachShader(simProg, compile(gl.VERTEX_SHADER, vsrc));
gl.attachShader(simProg, compile(gl.FRAGMENT_SHADER, document.getElementById("simFrag").textContent));
gl.linkProgram(simProg);

const prog = gl.createProgram();
gl.attachShader(prog, compile(gl.VERTEX_SHADER, vsrc));
gl.attachShader(prog, compile(gl.FRAGMENT_SHADER, document.getElementById("frag").textContent));
gl.linkProgram(prog);
if(!gl.getProgramParameter(prog, gl.LINK_STATUS)) console.error(gl.getProgramInfoLog(prog));

const buf = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buf);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1,3,-1,-1,3]), gl.STATIC_DRAW);

function bindVAO(program){
  const loc = gl.getAttribLocation(program, "p");
  gl.enableVertexAttribArray(loc);
  gl.vertexAttribPointer(loc, 2, gl.FLOAT, false, 0, 0);
}

let fbos = [], texs = [];
function makeFBO(){
  const tex = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, tex);
  gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,canvas.width,canvas.height,0,gl.RGBA,gl.UNSIGNED_BYTE,null);
  gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.LINEAR);
  const fbo = gl.createFramebuffer();
  gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
  gl.framebufferTexture2D(gl.FRAMEBUFFER,gl.COLOR_ATTACHMENT0,gl.TEXTURE_2D,tex,0);
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  return {fbo, tex};
}
function rebuildFBOs(){
  fbos = [makeFBO(), makeFBO()];
  texs = [fbos[0].tex, fbos[1].tex];
}
rebuildFBOs();
let ping = 0;

const loadTex = (url, unit, p, name) => {
  const tex = gl.createTexture();
  gl.activeTexture(gl.TEXTURE0+unit);
  gl.bindTexture(gl.TEXTURE_2D, tex);
  gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,1,1,0,gl.RGBA,gl.UNSIGNED_BYTE,new Uint8Array([0,0,0,0]));
  gl.useProgram(p);
  gl.uniform1i(gl.getUniformLocation(p, name), unit);
  const img = new Image();
  img.crossOrigin="anonymous";
  img.onload = () => {
    gl.activeTexture(gl.TEXTURE0+unit);
    gl.bindTexture(gl.TEXTURE_2D, tex);
    gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,img);
    gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.LINEAR);
  };
  img.src = url;
  return tex;
};

gl.useProgram(prog);
["01","09","08","07","06","05"].forEach((n,i) =>
  loadTex(`files/img/void/building${n}.png`, i, prog, `u_texB${i+1}`));
loadTex("files/img/void/skyline.png",        6, prog, "u_texSkyline");
loadTex("files/img/void/canalport-mask.png", 7, prog, "u_texWindow");
loadTex("files/img/mirror.png",             11, prog, "u_texMirror");

gl.useProgram(simProg);
gl.uniform1i(gl.getUniformLocation(simProg,"u_window"), 7);
gl.uniform1i(gl.getUniformLocation(simProg,"u_prev"),   10);

const bhTex = gl.createTexture();
gl.activeTexture(gl.TEXTURE0+8);
gl.bindTexture(gl.TEXTURE_2D, bhTex);
gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,1,1,0,gl.RGBA,gl.UNSIGNED_BYTE,new Uint8Array([0,0,0,255]));
gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE);
gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE);
gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.LINEAR);
gl.useProgram(prog);
gl.uniform1i(gl.getUniformLocation(prog,"u_texBH"), 8);
gl.uniform1i(gl.getUniformLocation(prog,"u_water"), 9);

const video = document.createElement("video");
video.loop=true; video.muted=true; video.playsInline=true;
const srcWebm=document.createElement("source"); srcWebm.src="files/mov/bh2.webm"; srcWebm.type="video/webm";
const srcMp4=document.createElement("source");  srcMp4.src="files/mov/bh.mp4";  srcMp4.type="video/mp4";
video.appendChild(srcWebm); video.appendChild(srcMp4);
video.play().catch(()=>{});
let videoReady=false;
video.addEventListener("playing",()=>{ videoReady=true; });

function uploadVideoTexture(){
  if(!videoReady||video.readyState<2) return;
  gl.activeTexture(gl.TEXTURE0+8);
  gl.bindTexture(gl.TEXTURE_2D, bhTex);
  gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,video);
  gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.LINEAR);
}

const U = {
  res:   gl.getUniformLocation(prog,"u_resolution"),
  time:  gl.getUniformLocation(prog,"u_time"),
  mouse: gl.getUniformLocation(prog,"u_mouse"),
  mode:  gl.getUniformLocation(prog,"u_mode"),
  blink: gl.getUniformLocation(prog,"u_blink"),
  flash: gl.getUniformLocation(prog,"u_flash"),
  shake: gl.getUniformLocation(prog,"u_shake"),
};
const SU = {
  res:  gl.getUniformLocation(simProg,"u_resolution"),
  time: gl.getUniformLocation(simProg,"u_time"),
  dt:   gl.getUniformLocation(simProg,"u_dt"),
};

let mx=0,my=0,cx=0,cy=0,mode=0,blink=0,flash=0,shake=0,
    phase="open",timer=0,start=0,lastNow=0,loopCount=0;

addEventListener("mousemove",e=>{
  mx=(e.clientX/innerWidth)*2-1;
  my=-(e.clientY/innerHeight)*2+1;
});
addEventListener("click",()=>{
  video.play().catch(()=>{});
  if(phase==="open"){ phase="closing"; start=performance.now(); }
});

function simStep(now){
  const dt = Math.min((now - lastNow) * 0.001, 0.05);
  gl.activeTexture(gl.TEXTURE0+10);
  gl.bindTexture(gl.TEXTURE_2D, texs[ping]);
  const next = 1 - ping;
  gl.bindFramebuffer(gl.FRAMEBUFFER, fbos[next].fbo);
  gl.viewport(0,0,canvas.width,canvas.height);
  gl.useProgram(simProg);
  bindVAO(simProg);
  gl.uniform2f(SU.res, canvas.width, canvas.height);
  gl.uniform1f(SU.time, now * 0.001);
  gl.uniform1f(SU.dt, dt);
  gl.drawArrays(gl.TRIANGLES, 0, 3);
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  ping = next;
}

function render(now){
  if(phase==="open" && now-timer>4500){ phase="closing"; start=now; }
  else if(phase==="closing"){
    blink=Math.min((now-start)/80,1);
    if(blink>=1){
      phase="black";
      start=now;
      
      mode++;
      if (mode === 4) {
        loopCount++;
        if (loopCount < 4) { 
          mode = 0;
        } else {
          loopCount = 0;
        }
      } else if (mode > 4) {
        mode = 0;
      }
      
    }
  }
  else if(phase==="black" && now-start>130){ phase="opening"; start=now; }
  else if(phase==="opening"){
    blink=1.0-Math.min((now-start)/80,1);
    if(blink<=0){ phase="open"; timer=now; blink=0; }
  }

  cx+=(mx-cx)*0.05; cy+=(my-cy)*0.05;

  if(mode===3){
    if(Math.random()<0.018) flash=1.0;
    flash*=0.86;
    shake=Math.max(flash,0.10*Math.sin(now*0.02)+0.06*Math.sin(now*0.06));
    uploadVideoTexture();
    simStep(now);
  } else {
    flash*=0.80; shake*=0.80;
  }

  gl.activeTexture(gl.TEXTURE0+9);
  gl.bindTexture(gl.TEXTURE_2D, texs[ping]);

  gl.viewport(0,0,canvas.width,canvas.height);
  gl.useProgram(prog);
  bindVAO(prog);

  gl.uniform2f(U.res,  canvas.width,canvas.height);
  gl.uniform1f(U.time, now*0.001);
  gl.uniform2f(U.mouse,cx,cy);
  gl.uniform1i(U.mode, mode);
  gl.uniform1f(U.blink,blink);
  gl.uniform1f(U.flash,flash);
  gl.uniform1f(U.shake,shake);

  gl.drawArrays(gl.TRIANGLES,0,3);

  lastNow = now;
  requestAnimationFrame(render);
}
requestAnimationFrame(render);
</script>
</body>
</html>