<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Visual File Browser</title>
  <style>
    html, body { margin: 0; height: 100%; overflow: hidden; background: #0b0b0b; }
    canvas { display: block; }
    #hud {
      position: fixed; left: 10px; top: 10px; z-index: 10;
      font: 12px/1.3 monospace; color: #d6d6d6;
      background: rgba(0,0,0,0.55); border: 1px solid rgba(255,255,255,0.15);
      padding: 10px; max-width: 520px;
      user-select: none;
    }
    #path { color: #9cff9c; }
    #help { color: #9aa0a6; margin-top: 6px; }
    #sel { margin-top: 8px; color: #ffd28a; }
  </style>
</head>
<body>
  <div id="hud">
    <div><span id="path"></span></div>
    <div id="sel">Selected: (none)</div>
    <div id="help">
      Click select • Double-click enter dir • Backspace up • Arrows pan • +/- zoom • 1 City • 2 Grid • 3 Rings
    </div>
  </div>

  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";

    // ---------- Fake filesystem data (replace later with JSON) ----------
    // Node format: { name, kind: "dir"|"file", type?, size?, children? }
    const FS = {
      name: "root",
      kind: "dir",
      children: [
        {
          name: "collections",
          kind: "dir",
          children: [
            {
              name: "rrrecords",
              kind: "dir",
              children: [
                { name: "README.nfo", kind: "file", type: "text", size: 12_000 },
                { name: "cover.jpg", kind: "file", type: "image", size: 2_300_000 },
                { name: "A1.wav", kind: "file", type: "audio", size: 55_000_000 },
                { name: "A2.wav", kind: "file", type: "audio", size: 49_000_000 },
                { name: "press.txt", kind: "file", type: "text", size: 8_000 },
              ]
            },
            {
              name: "bank_records_nyc",
              kind: "dir",
              children: [
                { name: "notes.txt", kind: "file", type: "text", size: 6_000 },
                { name: "artwork", kind: "dir", children: [
                  { name: "scan_01.png", kind: "file", type: "image", size: 4_800_000 },
                  { name: "scan_02.png", kind: "file", type: "image", size: 5_200_000 },
                ]},
                { name: "master.wav", kind: "file", type: "audio", size: 120_000_000 },
              ]
            }
          ]
        },
        {
          name: "releases",
          kind: "dir",
          children: [
            { name: "2017", kind: "dir", children: [
              { name: "release_01", kind: "dir", children: [
                { name: "track.wav", kind: "file", type: "audio", size: 61_000_000 },
                { name: "cover.png", kind: "file", type: "image", size: 3_100_000 },
              ]},
              { name: "release_02", kind: "dir", children: [
                { name: "track.wav", kind: "file", type: "audio", size: 58_000_000 },
                { name: "README.nfo", kind: "file", type: "text", size: 14_000 },
              ]},
            ]},
            { name: "2024", kind: "dir", children: [
              { name: "score", kind: "dir", children: [
                { name: "cue_01.wav", kind: "file", type: "audio", size: 42_000_000 },
                { name: "cue_02.wav", kind: "file", type: "audio", size: 47_000_000 },
              ]},
            ]}
          ]
        }
      ]
    };

    // ---------- Renderer / Scene ----------
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0b0b0b);

    // Lights (keep it simple, slightly "tool-ish")
    const hemi = new THREE.HemisphereLight(0xffffff, 0x111111, 0.85);
    scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, 0.75);
    dir.position.set(10, 18, 8);
    scene.add(dir);

    // Subtle grid floor
    const grid = new THREE.GridHelper(120, 60, 0x2a2a2a, 0x151515);
    grid.position.y = -0.01;
    scene.add(grid);

    // ---------- Camera (ORTHOGRAPHIC) ----------
    let vw = window.innerWidth, vh = window.innerHeight;
    let zoom = 40; // smaller = closer
    const camera = new THREE.OrthographicCamera(
      -vw/zoom, vw/zoom, vh/zoom, -vh/zoom, 0.1, 1000
    );
    camera.position.set(35, 35, 35);
    camera.lookAt(0, 0, 0);

    // ---------- Data navigation state ----------
    const stack = [FS]; // path stack
    let current = FS;
    let selectedId = null;
    let layoutMode = "city"; // "city" | "grid" | "rings"

    // HUD elements
    const elPath = document.getElementById("path");
    const elSel  = document.getElementById("sel");

    function pathString() {
      return "/" + stack.map(n => n.name).filter(Boolean).join("/").replace(/^root/, "");
    }
    function updateHUD() {
      elPath.textContent = pathString() || "/";
      if (selectedId == null) {
        elSel.textContent = "Selected: (none)";
      } else {
        const node = current.children?.[selectedId];
        if (!node) elSel.textContent = "Selected: (none)";
        else {
          const extra = node.kind === "file"
            ? ` • ${node.type ?? "file"} • ${prettyBytes(node.size ?? 0)}`
            : ` • dir • ${node.children?.length ?? 0} items`;
          elSel.textContent = `Selected: ${node.name}${extra}`;
        }
      }
    }

    function prettyBytes(n) {
      if (!n) return "0 B";
      const units = ["B","KB","MB","GB","TB"];
      let i = 0, x = n;
      while (x >= 1024 && i < units.length - 1) { x /= 1024; i++; }
      return `${x.toFixed(x >= 10 || i === 0 ? 0 : 1)} ${units[i]}`;
    }

    // ---------- Instanced rendering ----------
    const boxGeom = new THREE.BoxGeometry(1, 1, 1);
    const boxMat  = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.9, metalness: 0.05 });

    let inst = null;                 // THREE.InstancedMesh
    let idToNode = [];               // index => node
    let instanceColors = null;        // InstancedBufferAttribute via setColorAt

    // Highlight outline: a single wireframe cube scaled/positioned onto selected instance
    const outline = new THREE.LineSegments(
      new THREE.EdgesGeometry(new THREE.BoxGeometry(1,1,1)),
      new THREE.LineBasicMaterial({ color: 0xffd28a })
    );
    outline.visible = false;
    scene.add(outline);

    function typeColor(node) {
      if (node.kind === "dir") return new THREE.Color(0xa5a5a5);
      switch (node.type) {
        case "audio": return new THREE.Color(0xb7ffb7);
        case "image": return new THREE.Color(0x9cc7ff);
        case "text":  return new THREE.Color(0xffd28a);
        default:      return new THREE.Color(0xffffff);
      }
    }

    function sizeHeight(node) {
      // compress size -> height so huge audio files don’t become absurd
      const s = node.size ?? 0;
      if (node.kind === "dir") return 1.2 + (node.children?.length ?? 0) * 0.08;
      const h = Math.log2(Math.max(1, s)) / 6; // ~0..?
      return Math.max(0.6, Math.min(8, h));
    }

    function ensureInstanced(count) {
      if (inst) scene.remove(inst);
      inst = new THREE.InstancedMesh(boxGeom, boxMat, Math.max(1, count));
      inst.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
      inst.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(Math.max(1, count) * 3), 3);
      scene.add(inst);
    }

    function applyLayout() {
      const nodes = current.children ?? [];
      idToNode = nodes.slice();
      ensureInstanced(nodes.length);

      const dummy = new THREE.Object3D();

      if (layoutMode === "city") {
        // Directory platforms (clusters) feel: rows + variable heights
        const cols = Math.max(6, Math.floor(Math.sqrt(nodes.length)));
        const spacing = 2.2;
        for (let i = 0; i < nodes.length; i++) {
          const n = nodes[i];
          const x = (i % cols) * spacing;
          const z = Math.floor(i / cols) * spacing;
          const h = sizeHeight(n);

          dummy.position.set(x, h * 0.5, z);
          dummy.scale.set(1.4, h, 1.4);
          dummy.rotation.set(0, 0, 0);
          dummy.updateMatrix();

          inst.setMatrixAt(i, dummy.matrix);
          inst.setColorAt(i, typeColor(n));
        }
      } else if (layoutMode === "grid") {
        // Voxel blocks: tight dense grid, small variation
        const cols = Math.max(10, Math.floor(Math.sqrt(nodes.length) * 1.3));
        const spacing = 1.6;
        for (let i = 0; i < nodes.length; i++) {
          const n = nodes[i];
          const x = (i % cols) * spacing;
          const z = Math.floor(i / cols) * spacing;
          const h = Math.max(0.8, Math.min(5, sizeHeight(n)));

          dummy.position.set(x, h * 0.5, z);
          dummy.scale.set(1.0, h, 1.0);
          dummy.rotation.set(0, 0, 0);
          dummy.updateMatrix();

          inst.setMatrixAt(i, dummy.matrix);
          inst.setColorAt(i, typeColor(n));
        }
      } else {
        // Rings: depth-less orbit feel
        const center = new THREE.Vector3(0, 0, 0);
        const ringCount = Math.max(2, Math.floor(Math.sqrt(nodes.length) / 1.2));
        const rings = Array.from({ length: ringCount }, (_, r) => []);
        nodes.forEach((n, i) => rings[i % ringCount].push({ n, i }));

        let radius = 4;
        for (let r = 0; r < rings.length; r++) {
          const ring = rings[r];
          const step = (Math.PI * 2) / Math.max(6, ring.length);
          for (let k = 0; k < ring.length; k++) {
            const { n, i } = ring[k];
            const a = k * step;
            const x = Math.cos(a) * radius;
            const z = Math.sin(a) * radius;
            const h = sizeHeight(n);

            dummy.position.set(x, h * 0.5, z);
            dummy.scale.set(1.2, h, 1.2);
            dummy.rotation.set(0, a + Math.PI/2, 0);
            dummy.updateMatrix();

            inst.setMatrixAt(i, dummy.matrix);
            inst.setColorAt(i, typeColor(n));
          }
          radius += 3.0;
        }
      }

      inst.instanceMatrix.needsUpdate = true;
      if (inst.instanceColor) inst.instanceColor.needsUpdate = true;

      selectedId = null;
      outline.visible = false;
      frameCurrent();
      updateHUD();
    }

    function frameCurrent() {
      // Center the camera roughly on the instanced cloud
      // (simple heuristic: shift lookAt based on count + layout)
      const nodes = current.children ?? [];
      const n = nodes.length || 1;

      let cx = 0, cz = 0;

      if (layoutMode === "rings") {
        cx = 0; cz = 0;
      } else {
        const cols = layoutMode === "grid"
          ? Math.max(10, Math.floor(Math.sqrt(n) * 1.3))
          : Math.max(6, Math.floor(Math.sqrt(n)));

        const spacing = layoutMode === "grid" ? 1.6 : 2.2;
        const rows = Math.ceil(n / cols);

        cx = (cols - 1) * spacing * 0.5;
        cz = (rows - 1) * spacing * 0.5;
      }

      const target = new THREE.Vector3(cx, 0, cz);
      camera.lookAt(target);
    }

    // ---------- Picking / selection ----------
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    function onPointer(ev) {
      const rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((ev.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -(((ev.clientY - rect.top) / rect.height) * 2 - 1);

      raycaster.setFromCamera(mouse, camera);
      const hits = inst ? raycaster.intersectObject(inst) : [];
      if (!hits.length) return null;
      return hits[0];
    }

    function selectInstance(instanceId) {
      selectedId = instanceId;
      const node = current.children?.[instanceId];
      if (!node) {
        outline.visible = false;
        selectedId = null;
        updateHUD();
        return;
      }

      // Move outline to selected instance
      const m = new THREE.Matrix4();
      inst.getMatrixAt(instanceId, m);
      const pos = new THREE.Vector3();
      const quat = new THREE.Quaternion();
      const scl = new THREE.Vector3();
      m.decompose(pos, quat, scl);

      outline.position.copy(pos);
      outline.quaternion.copy(quat);
      outline.scale.copy(scl);
      outline.visible = true;

      updateHUD();
    }

    renderer.domElement.addEventListener("click", (ev) => {
      const hit = onPointer(ev);
      if (!hit) {
        selectedId = null;
        outline.visible = false;
        updateHUD();
        return;
      }
      selectInstance(hit.instanceId);
    });

    renderer.domElement.addEventListener("dblclick", (ev) => {
      const hit = onPointer(ev);
      if (!hit) return;
      const node = current.children?.[hit.instanceId];
      if (!node) return;

      if (node.kind === "dir") {
        stack.push(node);
        current = node;
        applyLayout();
      }
    });

    // ---------- Keyboard controls ----------
    window.addEventListener("keydown", (ev) => {
      // Layout switching
      if (ev.key === "1") { layoutMode = "city"; applyLayout(); }
      if (ev.key === "2") { layoutMode = "grid"; applyLayout(); }
      if (ev.key === "3") { layoutMode = "rings"; applyLayout(); }

      // Navigate up
      if (ev.key === "Backspace") {
        ev.preventDefault();
        if (stack.length > 1) {
          stack.pop();
          current = stack[stack.length - 1];
          applyLayout();
        }
      }

      // Pan camera (tool-like)
      const pan = 1.5;
      if (ev.key === "ArrowLeft")  camera.position.x -= pan;
      if (ev.key === "ArrowRight") camera.position.x += pan;
      if (ev.key === "ArrowUp")    camera.position.z -= pan;
      if (ev.key === "ArrowDown")  camera.position.z += pan;

      // Zoom (orthographic scale)
      if (ev.key === "+" || ev.key === "=") setZoom(zoom - 3);
      if (ev.key === "-" || ev.key === "_") setZoom(zoom + 3);
    });

    function setZoom(z) {
      zoom = Math.max(12, Math.min(120, z));
      resizeCamera();
    }

    function resizeCamera() {
      vw = window.innerWidth; vh = window.innerHeight;
      camera.left   = -vw / zoom;
      camera.right  =  vw / zoom;
      camera.top    =  vh / zoom;
      camera.bottom = -vh / zoom;
      camera.updateProjectionMatrix();
      renderer.setSize(vw, vh);
    }

    window.addEventListener("resize", resizeCamera);

    // ---------- Render loop ----------
    applyLayout();

    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }
    animate();
  </script>
</body>
</html>
