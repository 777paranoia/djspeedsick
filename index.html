<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>DJSPEEDSICK.COM</title>
<style>
  html,body{margin:0;padding:0;overflow:hidden;background:#000}
  canvas#c{position:fixed;inset:0;display:block;width:100vw;height:100vh;}

  #splash-screen{
    position: fixed;
    inset: 0;
    z-index: 9999;
    background: #000;
  }

  #background-overlay{
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    object-fit: cover;
  }

  #enter-button{
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    cursor: pointer;
    z-index: 2;
  }
</style>
</head>
<body>

<div id="splash-screen">
  <img id="background-overlay" src="files/img/aerial.png">
  <img id="enter-button"
       src="files/img/enter-transparency2.png"
       onclick="enterSite()">
</div>
<canvas id="c"></canvas>

<script>
function enterSite(){
  const splash = document.getElementById("splash-screen");
  const audio = document.getElementById("audioPlayer");
  if (audio) audio.play().catch(()=>{});
  splash.style.display = "none";
}
</script>

<script id="simFrag" type="x-shader/x-fragment">
precision highp float;
uniform sampler2D u_prev;
uniform sampler2D u_window;
uniform vec2  u_resolution;
uniform float u_time;
uniform float u_dt;

float hash(vec2 p){ return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453); }
float hash1(float x){ return fract(sin(x*127.1)*43758.5); }

void main(){
  vec2 uv = gl_FragCoord.xy / u_resolution;
  vec4 win = texture2D(u_window, uv);
  float isGlass = 1.0 - clamp(win.a, 0.0, 1.0);
  if(isGlass < 0.1){ gl_FragColor = vec4(0.0); return; }

  vec2 texel = 1.0 / u_resolution;
  vec4 prev = texture2D(u_prev, uv);

  float h    = prev.r;

  float band     = floor(uv.x * 12.0);
  float depthRd  = hash1(band * 9.17);
  float speedMul = mix(0.55, 1.55, depthRd);
  float thickMul = mix(0.65, 1.85, depthRd);

  float cols   = 36.0 + depthRd * 56.0;
  float colId  = floor(uv.x * cols);
  float colRnd = hash1(colId * 3.7 + 1.3);
  float colRnd2= hash1(colId * 7.1 + 5.9);

  float spawnT1  = step(0.935, fract(u_time * (0.12 + colRnd  * 0.16) * speedMul + colRnd2 * 13.7));
  float spawnT2  = step(0.965, fract(u_time * (0.08 + colRnd2 * 0.11) * speedMul + colRnd  * 7.3));
  float spawnRnd = hash(uv * vec2(1.0, 2.2) + vec2(floor(u_time * (1.7 + colRnd * 1.9)), band * 11.0));

  float spawnCol = (spawnT1 + spawnT2) * step(0.62, spawnRnd) * step(0.5, isGlass);
  float newDrop  = spawnCol * (0.85 + 1.35 * depthRd);

  vec4 above = texture2D(u_prev, uv - vec2(0.0, texel.y * (2.0 + depthRd * 2.0)));
  float flowIn = above.r * (0.22 + 0.38 * depthRd);

  float breakup  = mix(0.985, 0.965, hash(vec2(colId, floor(u_time*1.2 + depthRd*9.0))));
  float dryPulse = mix(0.00, 0.08, step(0.985, hash(vec2(colId*2.3, floor(u_time*0.8)))));

  h = h * (0.92 * breakup) + flowIn + newDrop * (0.045 * thickMul);
  h = clamp(h, 0.0, 1.0);

  h *= (0.989 - dryPulse*0.25);
  float flowOut = smoothstep(0.18, 0.88, h) * (0.20 + 0.22 * depthRd);
  h = clamp(h - flowOut, 0.0, 1.0);

  h *= isGlass;

  gl_FragColor = vec4(h, 0.0, depthRd, 1.0);
}
</script>

<script id="frag" type="x-shader/x-fragment">
precision highp float;

uniform vec2  u_resolution;
uniform float u_time;
uniform vec2  u_mouse;
uniform float u_blink;
uniform int   u_mode;
uniform float u_flash;
uniform float u_shake;

uniform sampler2D u_texB1,u_texB2,u_texB3,u_texB4,u_texB5,u_texB6;
uniform sampler2D u_texSkyline,u_texWindow;
uniform sampler2D u_texBH;
uniform sampler2D u_water;
uniform sampler2D u_texMirror;

#define PI 3.14159265359

float hash2(vec2 p){ return fract(sin(dot(p,vec2(12.9898,78.233)))*43758.5453); }
float hash1(float x){ return fract(sin(x*127.1)*43758.5); }
mat2 rot(float a){ float s=sin(a),c=cos(a); return mat2(c,-s,s,c); }

float sdBox(vec3 p,vec3 b){
  vec3 q=abs(p)-b;
  return length(max(q,0.0))+min(max(q.x,max(q.y,q.z)),0.0);
}

/* --- Mandelbulb DE --- */
float sdFractal(vec3 pos, float power, float rotA, float rotB){
  pos.xz *= rot(u_time * rotA);
  pos.yz *= rot(u_time * rotB);
  vec3 z = pos;
  float dr = 1.0;
  float r  = 0.0;
  // Lowered from 10 to 4. Huge performance gain.
  for(int i = 0; i < 4; i++){
    r = length(z);
    if(r > 2.0) break;
    float theta = acos(clamp(z.z / r, -1.0, 1.0));
    float phi   = atan(z.y, z.x);
    dr = pow(r, power - 1.0) * power * dr + 1.0;
    float zr = pow(r, power);
    theta *= power;
    phi   *= power;
    z = zr * vec3(sin(theta)*cos(phi), sin(theta)*sin(phi), cos(theta)) + pos;
  }
  return 0.5 * log(max(r, 1e-6)) * r / dr;
}

/* --- Shared color palette --- */
vec3 neonPalette(float t) {
  vec3 a = vec3(0.5, 0.5, 0.5);
  vec3 b = vec3(0.5, 0.5, 0.5);
  vec3 c = vec3(1.0, 1.0, 1.0);
  vec3 d = vec3(0.00, 0.33, 0.67);
  return a + b * cos(6.28318 * (c * t + d));
}

/* --- Mode 1: Pickover Stalks --- */
vec3 colorPickover(vec3 p) {
  vec2 c = vec2(p.x * 0.4 + sin(u_time * 0.07) * 0.3,
                p.y * 0.4 + cos(u_time * 0.05) * 0.3);
  vec2 z = vec2(0.0);
  float minDist = 1e10;
  float escapeI = 0.0;
  for(int i = 0; i < 80; i++) {
    z = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c;
    float d = min(abs(z.x), abs(z.y));
    if(d < minDist) minDist = d;
    if(dot(z,z) > 100.0){ escapeI = float(i); break; }
  }
  float trap = clamp(minDist * 8.0, 0.0, 1.0);
  float hue = fract(trap * 2.0 + u_time * 0.15 + escapeI * 0.01);
  return neonPalette(hue) * (0.4 + 0.6 * (1.0 - trap));
}

/* --- Mode 2: Clifford Attractor --- */
vec3 colorClifford(vec3 p) {
  float a  =  1.5 + sin(u_time * 0.11) * 0.4;
  float b  = -1.8 + cos(u_time * 0.07) * 0.3;
  float c2 = -1.9 + sin(u_time * 0.09) * 0.3;
  float d  =  0.4 + cos(u_time * 0.13) * 0.4;
  float x = p.x * 0.5 + p.z * 0.2;
  float y = p.y * 0.5 + p.z * 0.1;
  float density = 0.0;
  float hueAcc = 0.0;
  for(int i = 0; i < 48; i++){
    float nx = sin(a * y) + c2 * cos(a * x);
    float ny = sin(b * x) + d  * cos(b * y);
    x = nx; y = ny;
    density += exp(-length(vec2(x, y)) * 0.5);
    hueAcc  += atan(y, x);
  }
  density = clamp(density * 0.06, 0.0, 1.0);
  float hue = fract(hueAcc * 0.05 + u_time * 0.12);
  return neonPalette(hue) * (0.3 + 0.7 * density);
}

/* --- Per-fractal randomized properties --- */
vec3 fractalAnchor(float id){
  float x = mix(-1.6,  1.6,  hash1(id * 3.1));
  float y = mix(-0.8,  1.2,  hash1(id * 7.3));
  float z = mix( 4.5, 10.0,  hash1(id * 11.7));
  return vec3(x, y, z);
}
float fractalPower(float id){
  return mix(6.0, 10.0, hash1(id * 5.3)) + sin(u_time * mix(0.03, 0.08, hash1(id * 2.1))) * 1.5;
}
float fractalRotA(float id){ return mix(0.05, 0.18, hash1(id * 9.7))  * (hash1(id * 4.1) > 0.5 ? 1.0 : -1.0); }
float fractalRotB(float id){ return mix(0.04, 0.14, hash1(id * 6.3))  * (hash1(id * 8.9) > 0.5 ? 1.0 : -1.0); }
float fractalScale(float id){ return mix(1.8, 2.8, hash1(id * 13.1)); }
float fractalFogDensity(float id){ return mix(0.006, 0.03, hash1(id * 17.3)); }

float snow(vec2 uv,float size,float speed,float opacity){
  vec2 grid=uv*size;
  vec2 id=floor(grid);
  vec2 f=fract(grid)-0.5;
  f.y+=fract(u_time*speed+hash2(id)*15.0)-0.5;
  f.x+=sin(u_time*0.5+hash2(id)*6.2831)*0.2;
  return smoothstep(.05,0.0,length(f))*hash2(id)*opacity;
}

/* --- WORLD RAIN --- */
float worldRainLayer(vec2 uv, float t, float scale, float speed, float thickness, float density, float slant){
  vec2 u = uv;
  u.x *= u_resolution.x / u_resolution.y;
  u *= scale;
  u += vec2(slant, 1.0) * t * speed;
  vec2 id = floor(u);
  vec2 f  = fract(u);
  float n = hash2(id);
  float on = step(1.0 - density, n);
  float x = f.x - (0.5 + (n - 0.5) * 0.18);
  float streak = smoothstep(thickness, 0.0, abs(x));
  float seg = hash2(id + 19.17);
  float gate = smoothstep(0.15, 0.95, fract(f.y + seg));
  return on * streak * gate;
}

float worldRain(vec2 uv, float t){
  float r = 0.0;
  r += worldRainLayer(uv, t, 18.0, 1.8, 0.020, 0.10, 0.06);
  r += worldRainLayer(uv, t, 28.0, 2.4, 0.016, 0.13, 0.08);
  r += worldRainLayer(uv, t, 44.0, 3.2, 0.012, 0.16, 0.10);
  return clamp(r, 0.0, 1.0);
}

/* --- Scene --- */
/* --- Scene --- */
vec2 mapScene(vec3 p){
  vec2 res=vec2(1000.0,-1.0);
  float d1=sdBox(p-vec3(-3.0,0.0,2.0), vec3(1.2,12.0,1.5)); if(d1<res.x) res=vec2(d1,1.0);
  float d2=sdBox(p-vec3(-4.2,0.0,7.0), vec3(1.2,12.0,1.5)); if(d2<res.x) res=vec2(d2,2.0);
  float d3=sdBox(p-vec3(-5.4,0.0,12.0),vec3(1.2,12.0,1.5)); if(d3<res.x) res=vec2(d3,3.0);
  float d4=sdBox(p-vec3( 3.0,0.0,2.5), vec3(1.2,12.0,1.5)); if(d4<res.x) res=vec2(d4,4.0);
  float d5=sdBox(p-vec3( 4.2,0.0,7.5), vec3(1.2,12.0,1.5)); if(d5<res.x) res=vec2(d5,5.0);
  float d6=sdBox(p-vec3( 5.4,0.0,12.5),vec3(1.2,12.0,1.5)); if(d6<res.x) res=vec2(d6,6.0);

  if(u_mode == 1 || u_mode == 2){
    float seed = floor(u_time * 0.015);
    float num  = floor(hash1(seed * 31.1) * 3.0) + 1.0; 

    float id0 = seed * 7.0;
    float sc0 = fractalScale(id0);
    vec3  fp0 = (p - fractalAnchor(id0)) / sc0;
    float bound0 = length(fp0) - 3.0;
    float df0 = bound0;
    // Only run the trig math if the ray is physically near the fractal
    if(bound0 < 0.1) df0 = max(bound0, sdFractal(fp0, fractalPower(id0), fractalRotA(id0), fractalRotB(id0)));
    if(df0 / sc0 < res.x) res = vec2(df0 / sc0, 10.0);

    if(num >= 2.0){
      float id1 = seed * 7.0 + 1.0;
      float sc1 = fractalScale(id1);
      vec3  fp1 = (p - fractalAnchor(id1)) / sc1;
      float bound1 = length(fp1) - 3.0;
      float df1 = bound1;
      if(bound1 < 0.1) df1 = max(bound1, sdFractal(fp1, fractalPower(id1), fractalRotA(id1), fractalRotB(id1)));
      if(df1 / sc1 < res.x) res = vec2(df1 / sc1, 10.0);
    }

    if(num >= 3.0){
      float id2 = seed * 7.0 + 2.0;
      float sc2 = fractalScale(id2);
      vec3  fp2 = (p - fractalAnchor(id2)) / sc2;
      float bound2 = length(fp2) - 3.0;
      float df2 = bound2;
      if(bound2 < 0.1) df2 = max(bound2, sdFractal(fp2, fractalPower(id2), fractalRotA(id2), fractalRotB(id2)));
      if(df2 / sc2 < res.x) res = vec2(df2 / sc2, 10.0);
    }
  }

  return res;
}

vec3 sampleBuilding(float id,vec2 texUV){
  if(id > 9.0) return vec3(1.0);
  vec2 uv=abs(fract(texUV*0.25)*2.0-1.0);
  if(id<1.5) return texture2D(u_texB1,uv).rgb;
  if(id<2.5) return texture2D(u_texB2,uv).rgb;
  if(id<3.5) return texture2D(u_texB3,uv).rgb;
  if(id<4.5) return texture2D(u_texB4,uv).rgb;
  if(id<5.5) return texture2D(u_texB5,uv).rgb;
  return texture2D(u_texB6,uv).rgb;
}

vec2 waterNormal(vec2 uv){
  vec2 texel = 1.0 / u_resolution;
  float hL = texture2D(u_water, uv - vec2(texel.x, 0.0)).r;
  float hR = texture2D(u_water, uv + vec2(texel.x, 0.0)).r;
  float hD = texture2D(u_water, uv - vec2(0.0, texel.y)).r;
  float hU = texture2D(u_water, uv + vec2(0.0, texel.y)).r;
  return vec2(hL - hR, hD - hU) * 7.0;
}

void main(){
  vec2 uv=(gl_FragCoord.xy-0.5*u_resolution.xy)/u_resolution.y;
  vec2 screenUV=gl_FragCoord.xy/u_resolution.xy;
  vec2 m=u_mouse*0.35;

  vec3 ro=vec3(0.0,0.0,-4.5);
  vec3 rd=normalize(vec3(uv,1.4));
  rd.yz*=rot(-m.y*0.5);
  rd.xz*=rot(-m.x*0.6);

  if(u_mode==3){
    float sx=(hash2(vec2(floor(u_time*40.0),1.7))-0.5)*0.020*u_shake;
    float sy=(hash2(vec2(floor(u_time*40.0),8.3))-0.5)*0.016*u_shake;
    rd.xz*=rot(sx); rd.yz*=rot(sy);
  }

  float t=0.0; vec2 hit=vec2(0.0);
  for(int i=0;i<90;i++){
    hit=mapScene(ro+rd*t);
    if(hit.x<0.001||t>70.0) break;
    t+=hit.x;
  }
  bool isSky=(t>=70.0);

  vec3 colorStorm=vec3(0.008,0.018,0.040);
  vec3 skyTone=(u_mode==3)
    ? mix(colorStorm,vec3(0.015,0.030,0.060),exp(-max(rd.y,0.0)*3.5))
    : mix(vec3(0.01,0.02,0.04),vec3(0.35,0.20,0.08),exp(-max(rd.y,0.0)*4.0));

 vec3 sceneCol=vec3(0.0);

  if(!isSky){
    vec3 p=ro+rd*t;
    float fogAmt = (u_mode == 3) ? (1.0-exp(-0.004*t*t)) : (1.0-exp(-0.015*t*t));

    if(hit.y <= 9.0){
      // We hit a building, calculate 3D normals for lighting
      vec3 n=normalize(vec3(
        mapScene(p+vec3(0.01,0,0)).x-mapScene(p-vec3(0.01,0,0)).x,
        mapScene(p+vec3(0,0.01,0)).x-mapScene(p-vec3(0,0.01,0)).x,
        mapScene(p+vec3(0,0,0.01)).x-mapScene(p-vec3(0,0,0.01)).x
      ));
      vec2 texUV=(abs(n.x)>abs(n.y))?p.zy:p.xy;
      float buildAmt = (u_mode == 3) ? 0.08 : 0.09;
      sceneCol=mix(sampleBuilding(hit.y,texUV)*buildAmt, skyTone, fogAmt);
    }

    if(hit.y > 9.0){
      // We hit a fractal. Bypass the heavy normal math entirely.
      vec3 p2 = p; 

      // Find closest fractal center for localized fog
      float seed = floor(u_time * 0.015);
      float num  = floor(hash1(seed * 31.1) * 3.0) + 1.0;     float closestDist = 1e10;
      float closestFogD = 0.015;

      vec3 a0 = fractalAnchor(seed * 7.0);
      float dist0 = length(p2 - a0);
      if(dist0 < closestDist){ closestDist = dist0; closestFogD = fractalFogDensity(seed * 7.0); }

      if(num >= 2.0){
        vec3 a1 = fractalAnchor(seed * 7.0 + 1.0);
        float dist1 = length(p2 - a1);
        if(dist1 < closestDist){ closestDist = dist1; closestFogD = fractalFogDensity(seed * 7.0 + 1.0); }
      }
      if(num >= 3.0){
        vec3 a2 = fractalAnchor(seed * 7.0 + 2.0);
        float dist2 = length(p2 - a2);
        if(dist2 < closestDist){ closestDist = dist2; closestFogD = fractalFogDensity(seed * 7.0 + 2.0); }
      }

      // Tight fog â€” hugs close to fractal surface
      float inner = max(closestDist - 0.8, 0.0);
      float fractalFog = 1.0 - exp(-closestFogD * inner * inner);

      vec3 fractalCol;
      if(u_mode == 1){
        fractalCol = colorPickover(p2);
      } else {
        fractalCol = colorClifford(p2);
      }
      sceneCol = mix(fractalCol, skyTone * 0.12, fractalFog);
    }

    if(u_mode==3) sceneCol+=vec3(0.55,0.78,1.0)*u_flash*0.35;

  } else {
    if(u_mode==3){
      vec2 bhUV = rd.xy * 1.2 + vec2(0.5, 0.5);
      bhUV = clamp(bhUV, 0.001, 0.999);
      sceneCol=texture2D(u_texBH, bhUV).rgb;
    } else {
      vec2 skyUV=fract(rd.xy*0.5+0.5+vec2(u_time*0.002,0.0));
      sceneCol=texture2D(u_texSkyline,skyUV).rgb*0.3+skyTone*0.5;

      if(u_mode==1 || u_mode==2){
      }

      sceneCol+=snow(vec2(atan(rd.z,rd.x)*2.0,rd.y*2.0),15.0,0.3,0.3);
    }
  }

  if(u_mode==3){
    float wr = worldRain(uv, u_time);
    wr *= isSky ? 1.0 : 0.0;
    sceneCol += vec3(0.62,0.72,0.85) * wr * 0.65;
  }

  if(u_mode==4){
    vec2 suv = gl_FragCoord.xy / u_resolution.xy;
    sceneCol = texture2D(u_texMirror, vec2(suv.x, 1.0 - suv.y)).rgb;
  }

  // Window overlay
  float dWin=(-1.5-ro.z)/rd.z;
  if(dWin>0.0){
    vec3 pW=ro+rd*dWin;
    if(abs(pW.x)<4.0&&abs(pW.y)<3.0){
      vec2 wuv=vec2(pW.x*0.25+0.5,0.5-pW.y*0.25);
      vec4 txW=texture2D(u_texWindow,wuv);
      float frameA=clamp(txW.a,0.0,1.0);
      float isGlass=1.0-frameA;

      if(isGlass>0.1 && u_mode==3){
        float waterH = texture2D(u_water, wuv).r;
        vec2  wNorm  = waterNormal(wuv);
        float highlight = clamp(dot(normalize(wNorm), normalize(vec2(0.25,0.85))), 0.0, 1.0);
        highlight = pow(highlight, 7.0) * waterH * 1.6;
        float wetness = clamp(waterH * 2.6, 0.0, 0.38);
        float useBH = isSky ? 1.0 : 0.0;
        vec2 bhUV = rd.xy * 1.2 + vec2(0.5, 0.5);
        vec2 refractUV = bhUV + wNorm * 0.020;
        refractUV = clamp(refractUV, 0.001, 0.999);
        vec3 refracted = texture2D(u_texBH, refractUV).rgb;
        float refractAmt = clamp((waterH - 0.12) * 7.0, 0.0, 0.65) * useBH;
        sceneCol = mix(sceneCol, refracted, refractAmt);
        sceneCol += vec3(0.62,0.78,1.0) * highlight;
        sceneCol = mix(sceneCol, sceneCol * 0.72, wetness);
      } else if(isGlass>0.1 && u_mode!=3){
        float frost = hash2(wuv*80.0)*0.04;
        sceneCol = mix(sceneCol, vec3(0.6,0.7,0.8), frost*0.3);
      }

      vec3 frameCol=txW.rgb*0.50;
      if(u_mode==3) frameCol+=vec3(0.55,0.78,1.0)*u_flash*0.55;
      sceneCol=mix(sceneCol,frameCol,frameA);
    }
  }

  float dimmer = (u_mode == 3) ? 1.0 : 0.55;
  gl_FragColor=vec4(sceneCol*(1.0-u_blink)*dimmer,1.0);
}
</script>

<script>
const canvas = document.getElementById("c");
const gl = canvas.getContext("webgl", { antialias:false, alpha:false });
gl.getExtension("OES_texture_float") || gl.getExtension("OES_texture_half_float");

const fit = () => {
  const dpr = Math.min(2, devicePixelRatio||1);
  canvas.width  = Math.floor(innerWidth  * dpr);
  canvas.height = Math.floor(innerHeight * dpr);
  gl.viewport(0,0,canvas.width,canvas.height);
};
addEventListener("resize", () => { fit(); rebuildFBOs(); }); fit();

const compile = (type, src) => {
  const sh = gl.createShader(type);
  gl.shaderSource(sh, src);
  gl.compileShader(sh);
  if(!gl.getShaderParameter(sh, gl.COMPILE_STATUS)) console.error(gl.getShaderInfoLog(sh));
  return sh;
};

const vsrc = `attribute vec2 p; void main(){ gl_Position=vec4(p,0,1); }`;

const simProg = gl.createProgram();
gl.attachShader(simProg, compile(gl.VERTEX_SHADER, vsrc));
gl.attachShader(simProg, compile(gl.FRAGMENT_SHADER, document.getElementById("simFrag").textContent));
gl.linkProgram(simProg);

const prog = gl.createProgram();
gl.attachShader(prog, compile(gl.VERTEX_SHADER, vsrc));
gl.attachShader(prog, compile(gl.FRAGMENT_SHADER, document.getElementById("frag").textContent));
gl.linkProgram(prog);
if(!gl.getProgramParameter(prog, gl.LINK_STATUS)) console.error(gl.getProgramInfoLog(prog));

const buf = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buf);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1,3,-1,-1,3]), gl.STATIC_DRAW);

function bindVAO(program){
  const loc = gl.getAttribLocation(program, "p");
  gl.enableVertexAttribArray(loc);
  gl.vertexAttribPointer(loc, 2, gl.FLOAT, false, 0, 0);
}

let fbos = [], texs = [];
function makeFBO(){
  const tex = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, tex);
  gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,canvas.width,canvas.height,0,gl.RGBA,gl.UNSIGNED_BYTE,null);
  gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.LINEAR);
  const fbo = gl.createFramebuffer();
  gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
  gl.framebufferTexture2D(gl.FRAMEBUFFER,gl.COLOR_ATTACHMENT0,gl.TEXTURE_2D,tex,0);
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  return {fbo, tex};
}
function rebuildFBOs(){
  fbos = [makeFBO(), makeFBO()];
  texs = [fbos[0].tex, fbos[1].tex];
}
rebuildFBOs();
let ping = 0;

const loadTex = (url, unit, p, name) => {
  const tex = gl.createTexture();
  gl.activeTexture(gl.TEXTURE0+unit);
  gl.bindTexture(gl.TEXTURE_2D, tex);
  gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,1,1,0,gl.RGBA,gl.UNSIGNED_BYTE,new Uint8Array([0,0,0,0]));
  gl.useProgram(p);
  gl.uniform1i(gl.getUniformLocation(p, name), unit);
  const img = new Image();
  img.crossOrigin="anonymous";
  img.onload = () => {
    gl.activeTexture(gl.TEXTURE0+unit);
    gl.bindTexture(gl.TEXTURE_2D, tex);
    gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,img);
    gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.LINEAR);
  };
  img.src = url;
  return tex;
};

gl.useProgram(prog);
["01","09","08","07","06","05"].forEach((n,i) =>
  loadTex(`files/img/void/building${n}.png`, i, prog, `u_texB${i+1}`));
loadTex("files/img/void/skyline.png",        6, prog, "u_texSkyline");
loadTex("files/img/void/canalport-mask.png", 7, prog, "u_texWindow");
loadTex("files/img/mirror.png",             11, prog, "u_texMirror");

gl.useProgram(simProg);
gl.uniform1i(gl.getUniformLocation(simProg,"u_window"), 7);
gl.uniform1i(gl.getUniformLocation(simProg,"u_prev"),   10);

const bhTex = gl.createTexture();
gl.activeTexture(gl.TEXTURE0+8);
gl.bindTexture(gl.TEXTURE_2D, bhTex);
gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,1,1,0,gl.RGBA,gl.UNSIGNED_BYTE,new Uint8Array([0,0,0,255]));
gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE);
gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE);
gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.LINEAR);
gl.useProgram(prog);
gl.uniform1i(gl.getUniformLocation(prog,"u_texBH"), 8);
gl.uniform1i(gl.getUniformLocation(prog,"u_water"), 9);

const video = document.createElement("video");
video.loop=true; video.muted=true; video.playsInline=true;
const srcWebm=document.createElement("source"); srcWebm.src="files/mov/bh2.webm"; srcWebm.type="video/webm";
const srcMp4=document.createElement("source");  srcMp4.src="files/mov/bh.mp4";  srcMp4.type="video/mp4";
video.appendChild(srcWebm); video.appendChild(srcMp4);
video.play().catch(()=>{});
let videoReady=false;
video.addEventListener("playing",()=>{ videoReady=true; });

function uploadVideoTexture(){
  if(!videoReady||video.readyState<2) return;
  gl.activeTexture(gl.TEXTURE0+8);
  gl.bindTexture(gl.TEXTURE_2D, bhTex);
  gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,video);
  gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.LINEAR);
}

const U = {
  res:   gl.getUniformLocation(prog,"u_resolution"),
  time:  gl.getUniformLocation(prog,"u_time"),
  mouse: gl.getUniformLocation(prog,"u_mouse"),
  mode:  gl.getUniformLocation(prog,"u_mode"),
  blink: gl.getUniformLocation(prog,"u_blink"),
  flash: gl.getUniformLocation(prog,"u_flash"),
  shake: gl.getUniformLocation(prog,"u_shake"),
};
const SU = {
  res:  gl.getUniformLocation(simProg,"u_resolution"),
  time: gl.getUniformLocation(simProg,"u_time"),
  dt:   gl.getUniformLocation(simProg,"u_dt"),
};

let mx=0,my=0,cx=0,cy=0,mode=0,blink=0,flash=0,shake=0,
    phase="open",timer=-9999,start=0,lastNow=0,loopCount=0,
    blinkCount=0,targetBlinks=2;

addEventListener("mousemove",e=>{
  mx=(e.clientX/innerWidth)*2-1;
  my=-(e.clientY/innerHeight)*2+1;
});
addEventListener("click",()=>{
  video.play().catch(()=>{});
});

function simStep(now){
  const dt = Math.min((now - lastNow) * 0.001, 0.05);
  gl.activeTexture(gl.TEXTURE0+10);
  gl.bindTexture(gl.TEXTURE_2D, texs[ping]);
  const next = 1 - ping;
  gl.bindFramebuffer(gl.FRAMEBUFFER, fbos[next].fbo);
  gl.viewport(0,0,canvas.width,canvas.height);
  gl.useProgram(simProg);
  bindVAO(simProg);
  gl.uniform2f(SU.res, canvas.width, canvas.height);
  gl.uniform1f(SU.time, now * 0.001);
  gl.uniform1f(SU.dt, dt);
  gl.drawArrays(gl.TRIANGLES, 0, 3);
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  ping = next;
}

function advanceMode(){
  mode++;
  if(mode === 3 || mode === 4){
    // BH and mirror always last exactly one blink
    targetBlinks = 1;
    blinkCount = 0;
  }
  if(mode === 4){
    loopCount++;
    if(loopCount < 2){ // mirror every 2 full cycles
      mode = 0;
    } else {
      loopCount = 0;
    }
  } else if(mode > 4){
    mode = 0;
  }
}

function render(now){
  if(phase==="open" && now-timer>4500){
    blinkCount++;
    if(blinkCount >= targetBlinks){
      targetBlinks = 2 + Math.floor(Math.random() * 5);
      blinkCount = 0;
      phase="closing_switch"; start=now; timer=now;
    } else {
      phase="closing_blink"; start=now; timer=now;
    }
  }
  else if(phase==="closing_blink"){
    blink=Math.min((now-start)/160,1);
    if(blink>=1){ phase="black_blink"; start=now; }
  }
  else if(phase==="black_blink" && now-start>120){
    phase="opening_blink"; start=now;
  }
  else if(phase==="opening_blink"){
    blink=1.0-Math.min((now-start)/160,1);
    if(blink<=0){ phase="open"; timer=now; blink=0; }
  }
  else if(phase==="closing_switch"){
    blink=Math.min((now-start)/160,1);
    if(blink>=1){
      phase="black_switch"; start=now;
      advanceMode();
    }
  }
  else if(phase==="black_switch" && now-start>200){
    phase="opening_switch"; start=now;
  }
  else if(phase==="opening_switch"){
    blink=1.0-Math.min((now-start)/160,1);
    if(blink<=0){ phase="open"; timer=now; blink=0; }
  }

  cx+=(mx-cx)*0.05; cy+=(my-cy)*0.05;

  if(mode===3){
    if(Math.random()<0.018) flash=1.0;
    flash*=0.86;
    shake=Math.max(flash,0.10*Math.sin(now*0.02)+0.06*Math.sin(now*0.06));
    uploadVideoTexture();
    simStep(now);
  } else {
    flash*=0.80; shake*=0.80;
  }

  gl.activeTexture(gl.TEXTURE0+9);
  gl.bindTexture(gl.TEXTURE_2D, texs[ping]);
  gl.viewport(0,0,canvas.width,canvas.height);
  gl.useProgram(prog);
  bindVAO(prog);
  gl.uniform2f(U.res,  canvas.width,canvas.height);
  gl.uniform1f(U.time, now*0.001);
  gl.uniform2f(U.mouse,cx,cy);
  gl.uniform1i(U.mode, mode);
  gl.uniform1f(U.blink,blink);
  gl.uniform1f(U.flash,flash);
  gl.uniform1f(U.shake,shake);
  gl.drawArrays(gl.TRIANGLES,0,3);

  lastNow = now;
  requestAnimationFrame(render);
}
requestAnimationFrame(render);
</script>
</body>
</html>