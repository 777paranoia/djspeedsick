<!doctype html>
<html>
<body style="margin:0;background:black;overflow:hidden">
<canvas id="c"></canvas>
<script>
const canvas = document.getElementById("c");
const gl = canvas.getContext("webgl");
if(!gl) document.body.textContent="WebGL unavailable";

const vert = `
attribute vec2 p;
void main(){ gl_Position = vec4(p,0.0,1.0); }
`;

const frag = `
precision highp float;

uniform vec2 r;
uniform float t;

/* ---- Mandelbrot escape — used only for surface coloring ---- */
float mandel(vec2 c){
  vec2 z = vec2(0.0);
  float it = 0.0;
  for(int i=0;i<64;i++){
    z = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c;
    if(dot(z,z) > 4.0){ it = float(i); break; }
  }
  return it / 64.0;
}

/* ---- Rotations ---- */
mat3 rotY(float a){
  float c=cos(a), s=sin(a);
  return mat3(c,0,s, 0,1,0, -s,0,c);
}
mat3 rotX(float a){
  float c=cos(a), s=sin(a);
  return mat3(1,0,0, 0,c,-s, 0,s,c);
}

/* ---- Mandelbox DE ---- */
float mandelbox(vec3 p){
  vec3 z = p;
  float scale = 2.0;
  float dr = 1.0;
  for(int i=0;i<12;i++){
    z = clamp(z,-1.0,1.0)*2.0 - z;
    float r2 = dot(z,z);
    if(r2 < 0.25)      z *= 4.0;
    else if(r2 < 1.0)  z *= 1.0/r2;
    z = scale*z + p;
    dr = dr*abs(scale) + 1.0;
  }
  return length(z)/abs(dr);
}

/* ---- Scene: pure 3D Mandelbox with slow rotation ---- */
float map(vec3 p){
  p *= rotY(t * 0.08);
  p *= rotX(t * 0.05);
  return mandelbox(p);
}

/* ---- Normal ---- */
vec3 normal(vec3 p){
  float e = 0.002;
  vec2 h = vec2(e,0);
  return normalize(vec3(
    map(p+h.xyy)-map(p-h.xyy),
    map(p+h.yxy)-map(p-h.yxy),
    map(p+h.yyx)-map(p-h.yyx)
  ));
}

/* ---- Plasma palette (from bak_) ---- */
vec3 palette(float x){
  return 0.5 + 0.5*cos(6.283*(x + vec3(0.0, 0.33, 0.67)));
}

void main(){

  /* Clean UV — no distortion */
  vec2 uv = (gl_FragCoord.xy / r - 0.5) * 2.0;
  uv.x *= r.x / r.y;

  /* Camera slowly orbits the fractal */
  float camAngle = t * 0.04;
  vec3 ro = vec3(sin(camAngle)*4.5, -1.5 + sin(t*0.03)*0.8, cos(camAngle)*4.5);
  vec3 fwd = normalize(-ro);
  vec3 right = normalize(cross(vec3(0,1,0), fwd));
  vec3 up = cross(fwd, right);
  vec3 rd = normalize(fwd*1.5 + uv.x*right + uv.y*up);

  /* Raymarch */
  float dist = 0.1;
  float hit = -1.0;
  float steps = 0.0;

  for(int i=0;i<120;i++){
    vec3 p = ro + rd * dist;
    float h = map(p);
    if(h < 0.001){ hit = 1.0; break; }
    dist += h;
    steps += 1.0;
    if(dist > 30.0) break;
  }

  vec3 col = vec3(0.0);

  if(hit > 0.5){
    vec3 p = ro + rd * dist;
    vec3 n = normal(p);

    /* Sample Mandelbrot at surface XZ projection — drives hue variation */
    vec2 surfUV = p.xz * 0.28 + vec2(-0.5, 0.0);
    float mVal = mandel(surfUV);

    vec3 light = normalize(vec3(0.6, 1.0, -0.4));
    float diff = max(dot(n, light), 0.0);
    float rim  = pow(1.0 - max(dot(n, -rd), 0.0), 3.0);

    /* Hue = depth + mandelbrot surface reading + slow time */
    float hue = dist * 0.12 + mVal * 0.8 + t * 0.02;

    col = palette(hue);
    col *= diff * 1.4 + 0.25;
    col += palette(hue + 0.5) * rim * 0.4;
    col *= exp(-0.05 * dist);

    /* AO approximation from step count */
    col *= 0.5 + 0.5*(1.0 - steps/120.0);
  }

  gl_FragColor = vec4(col, 1.0);
}
`;

function compile(type, src){
  const s = gl.createShader(type);
  gl.shaderSource(s, src);
  gl.compileShader(s);
  if(!gl.getShaderParameter(s, gl.COMPILE_STATUS))
    console.error(gl.getShaderInfoLog(s));
  return s;
}

const prog = gl.createProgram();
gl.attachShader(prog, compile(gl.VERTEX_SHADER, vert));
gl.attachShader(prog, compile(gl.FRAGMENT_SHADER, frag));
gl.linkProgram(prog);
if(!gl.getProgramParameter(prog, gl.LINK_STATUS))
  console.error(gl.getProgramInfoLog(prog));
gl.useProgram(prog);

const buf = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buf);
gl.bufferData(gl.ARRAY_BUFFER,
  new Float32Array([-1,-1, 3,-1, -1,3]),
  gl.STATIC_DRAW);

const loc = gl.getAttribLocation(prog, "p");
gl.enableVertexAttribArray(loc);
gl.vertexAttribPointer(loc, 2, gl.FLOAT, false, 0, 0);

const ur = gl.getUniformLocation(prog, "r");
const ut = gl.getUniformLocation(prog, "t");

function resize(){
  canvas.width  = innerWidth;
  canvas.height = innerHeight;
  gl.viewport(0, 0, canvas.width, canvas.height);
}
addEventListener("resize", resize);
resize();

function frame(ms){
  gl.uniform2f(ur, canvas.width, canvas.height);
  gl.uniform1f(ut, ms * 0.001);
  gl.drawArrays(gl.TRIANGLES, 0, 3);
  requestAnimationFrame(frame);
}
frame(0);
</script>
</body>
</html>