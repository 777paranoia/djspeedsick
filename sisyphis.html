<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>GEOGRAPHIC_DEFRAG // BRUTALIST_SISYPHUS</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: 'Courier New', monospace; cursor: none; }
        canvas { display: block; filter: contrast(180%) brightness(110%); }
    </style>
</head>
<body>
<canvas id="c"></canvas>

<script>
/**
 * BRUTALIST TOPOGRAPHY // CORNER_CALCULATION
 */
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let w, h, frame = 0;
const COLS = 50, ROWS = 50, SIZE = 22;
let mesh = [];
let agent = { x: 25, z: 25, target: null, calc: 0 };

function init() {
    w = canvas.width = window.innerWidth;
    h = canvas.height = window.innerHeight;
    for(let i=0; i<COLS; i++) {
        mesh[i] = [];
        for(let j=0; j<ROWS; j++) {
            mesh[i][j] = { y: 0, morph: 0, v: 0 };
        }
    }
}

function project(x, y, z) {
    let rotX = 0.9, rotY = frame * 0.003;
    let x1 = x * Math.cos(rotY) - z * Math.sin(rotY);
    let z1 = x * Math.sin(rotY) + z * Math.cos(rotY);
    let y2 = y * Math.cos(rotX) - z1 * Math.sin(rotX);
    let z2 = y * Math.sin(rotX) + z1 * Math.cos(rotX);
    let scale = 1100 / (1100 + z2 + 800);
    return { x: w/2 + x1 * scale, y: h/2 + y2 * scale };
}

function update() {
    frame++;
    // THE ENTROPY: Liquid geographic bubbling
    for(let i=0; i<COLS; i++) {
        for(let j=0; j<ROWS; j++) {
            let m = mesh[i][j];
            let n = Math.sin(i*0.15 + frame*0.04) * Math.cos(j*0.15 + frame*0.03) * 70;
            // Domes are "soft" unless the agent is calculating their corners
            if (m.morph < 0.5) {
                m.y += (n - m.y) * 0.08;
                m.morph = Math.max(0, m.morph - 0.01);
            }
        }
    }

    // THE AGENT: Polyhedric Resolver
    if (!agent.target) {
        let rx = Math.floor(Math.random() * COLS);
        let rz = Math.floor(Math.random() * ROWS);
        agent.target = mesh[rx][rz];
        agent.calc = 0;
    } else {
        agent.calc += 0.9;
        agent.target.morph += 0.04; // Adding corners
        
        // As corners are calculated, height is suppressed into a flat crystal
        agent.target.y *= 0.92; 

        // THE SISYPHUS LIMIT: Panic/Abandonment
        if (agent.calc > 90 || Math.random() < 0.01) {
            agent.target = null;
        }
    }
}

function draw() {
    // THE FEEDBACK: Additive "Smear" (Mimicking your 3rd image)
    ctx.save();
    ctx.globalAlpha = 0.94;
    ctx.drawImage(canvas, 1, 1, w-2, h-2);
    ctx.restore();

    ctx.fillStyle = 'rgba(0,0,0,0.1)';
    ctx.fillRect(0, 0, w, h);

    ctx.lineWidth = 1;
    for(let i=0; i<COLS-1; i++) {
        for(let j=0; j<ROWS-1; j++) {
            let m = mesh[i][j];
            let p1 = project((i-COLS/2)*SIZE, m.y, (j-ROWS/2)*SIZE);
            let p2 = project((i+1-COLS/2)*SIZE, mesh[i+1][j].y, (j-ROWS/2)*SIZE);
            let p3 = project((i-COLS/2)*SIZE, mesh[i][j+1].y, (j+1-ROWS/2)*SIZE);
            
            ctx.beginPath();
            // Spheric = Red/Pink wireframe. Polyhedric = Cyan sharp crystal.
            ctx.strokeStyle = m.morph > 0.4 ? '#00ffff' : '#ff0055';
            ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.lineTo(p3.x, p3.y);
            ctx.closePath();
            ctx.stroke();

            // Crystallization density (from your 2nd image)
            if (m.morph > 0.8) {
                ctx.strokeStyle = '#fff';
                ctx.strokeRect(p1.x-2, p1.y-2, 4, 4);
            }
        }
    }
}

init();
function loop() { update(); draw(); requestAnimationFrame(loop); }
loop();
window.onresize = init;
</script>
</body>
</html>